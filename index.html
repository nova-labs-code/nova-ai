<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Advanced Paint + Smudge</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;width:100%;height:100%;background:#111;color:white;font-family:sans-serif;}
#controls{
  position:absolute;top:10px;left:10px;z-index:10;background:rgba(0,0,0,0.5);padding:8px;border-radius:5px;
}
canvas{display:block;}
input,select,button{margin:0 5px;}
</style>
</head>
<body>
<div id="controls">
Color: <input type="color" id="color" value="#ff0000">
Size: <input type="range" id="size" min="5" max="100" value="20">
Strength: <input type="range" id="strength" min="0.01" max="1" step="0.01" value="0.3">
Tool: 
<select id="tool">
  <option value="paint">Paint</option>
  <option value="smudge">Smudge</option>
  <option value="eraser">Eraser</option>
  <option value="spray">Spray</option>
  <option value="square">Square Brush</option>
</select>
<button id="undo">Undo</button>
<button id="redo">Redo</button>
<button id="clear">Clear</button>
<button id="saveImg">Save Image</button>
<button id="saveJSON">Save JSON</button>
<input type="file" id="loadJSON">
<input type="file" id="loadImage">
</div>

<canvas id="canvas"></canvas>
<script>
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

// Pixel ID tracking
let pixelIDs=[], nextID=1, history=[], redoStack=[];

// Resize
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  pixelIDs = Array.from({length:canvas.height},()=>Array(canvas.width).fill(0));
}
window.addEventListener("resize",resize);resize();

// Controls
const colorInput=document.getElementById("color");
const sizeInput=document.getElementById("size");
const strengthInput=document.getElementById("strength");
const toolSelect=document.getElementById("tool");
const clearBtn=document.getElementById("clear");
const undoBtn=document.getElementById("undo");
const redoBtn=document.getElementById("redo");
const saveImgBtn=document.getElementById("saveImg");
const saveJSONBtn=document.getElementById("saveJSON");
const loadJSONInput=document.getElementById("loadJSON");
const loadImageInput=document.getElementById("loadImage");

// History
function saveHistory(){
  const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const idsCopy = pixelIDs.map(row=>[...row]);
  history.push({img: imgData, ids: idsCopy});
  if(history.length>50) history.shift();
  redoStack=[];
}

function undo(){
  if(history.length===0) return;
  redoStack.push({img: ctx.getImageData(0,0,canvas.width,canvas.height), ids: pixelIDs.map(row=>[...row])});
  const last = history.pop();
  ctx.putImageData(last.img,0,0);
  pixelIDs = last.ids.map(row=>[...row]);
}

function redo(){
  if(redoStack.length===0) return;
  history.push({img: ctx.getImageData(0,0,canvas.width,canvas.height), ids: pixelIDs.map(row=>[...row])});
  const last = redoStack.pop();
  ctx.putImageData(last.img,0,0);
  pixelIDs = last.ids.map(row=>[...row]);
}

// Save/Load
function downloadCanvas(){
  const link=document.createElement("a");
  link.download="painting.png";
  link.href=canvas.toDataURL();
  link.click();
}

function downloadJSON(){
  const data = {pixelIDs: pixelIDs, image: canvas.toDataURL()};
  const blob = new Blob([JSON.stringify(data)],{type:"application/json"});
  const link=document.createElement("a");
  link.href=URL.createObjectURL(blob);
  link.download="painting.json";
  link.click();
}

function loadJSON(e){
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    const data = JSON.parse(evt.target.result);
    pixelIDs = data.pixelIDs;
    const img = new Image();
    img.onload = ()=>ctx.drawImage(img,0,0,canvas.width,canvas.height);
    img.src = data.image;
  }
  reader.readAsText(file);
}

// Image upload â†’ paint
loadImageInput.addEventListener("change", function(e){
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    const img = new Image();
    img.onload = function(){
      saveHistory();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const brushSize = Math.min(parseInt(sizeInput.value), 15);
      const half = Math.floor(brushSize/2);
      const step = half/2;

      const offCanvas = document.createElement("canvas");
      offCanvas.width = canvas.width;
      offCanvas.height = canvas.height;
      const offCtx = offCanvas.getContext("2d");
      offCtx.drawImage(img,0,0,canvas.width,canvas.height);
      const imgData = offCtx.getImageData(0,0,canvas.width,canvas.height);
      const data = imgData.data;

      for(let y=0; y<canvas.height; y+=step){
        for(let x=0; x<canvas.width; x+=step){
          const ix = (Math.floor(y)*canvas.width + Math.floor(x))*4;
          const r = data[ix], g = data[ix+1], b = data[ix+2], a = data[ix+3];
          if(a>0){
            ctx.fillStyle = `rgba(${r},${g},${b},1)`; // fully visible
            ctx.beginPath();
            ctx.arc(Math.floor(x), Math.floor(y), half, 0, Math.PI*2);
            ctx.fill();

            for(let py=Math.floor(y-half); py<Math.floor(y+half); py++){
              if(py<0||py>=canvas.height) continue;
              for(let px=Math.floor(x-half); px<Math.floor(x+half); px++){
                if(px<0||px>=canvas.width) continue;
                pixelIDs[py][px] = nextID++;
              }
            }
          }
        }
      }
    }
    img.src = evt.target.result;
  }
  reader.readAsDataURL(file);
});

// Drawing helpers
let drawing=false,lastX=0,lastY=0;
function getPos(e){if(e.touches&&e.touches.length>0)return{x:e.touches[0].clientX,y:e.touches[0].clientY};return{x:e.clientX,y:e.clientY};}
function startDraw(e){drawing=true; saveHistory(); const pos=getPos(e); lastX=pos.x; lastY=pos.y;}
function endDraw(){drawing=false;}

function interpolate(x0,y0,x1,y1,step){
  const points=[];
  const dist=Math.hypot(x1-x0,y1-y0);
  const steps=Math.ceil(dist/step);
  for(let i=0;i<=steps;i++){
    const t=i/steps;
    points.push({x:x0*(1-t)+x1*t, y=y0*(1-t)+y1*t});
  }
  return points;
}

function createBrushMask(radius){
  const size=radius*2;
  const mask=new Float32Array(size*size);
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const dx=x-radius+0.5,dy=y-radius+0.5;
      const d=Math.sqrt(dx*dx+dy*dy);
      mask[y*size+x]=Math.max(0,1-d/radius)**2;
    }
  }
  return mask;
}

function isPainted(r,g,b,a){ return a>0; }

function draw(e){
  if(!drawing) return;
  e.preventDefault();
  const pos=getPos(e);
  const x=pos.x|0, y=pos.y|0; 
  const brushSize=parseInt(sizeInput.value);
  const strength=parseFloat(strengthInput.value);
  const tool = toolSelect.value;
  const half=Math.floor(brushSize/2);

  if(tool==="paint" || tool==="eraser" || tool==="square" || tool==="spray"){
    ctx.globalCompositeOperation = (tool==="eraser") ? "destination-out" : "source-over";
    ctx.fillStyle = (tool==="eraser") ? "rgba(0,0,0,1)" : colorInput.value;
    const points = interpolate(lastX,lastY,x,y,1);

    for(const pt of points){
      if(tool==="spray"){
        for(let i=0;i<brushSize;i++){
          const angle=Math.random()*Math.PI*2;
          const r=Math.random()*half;
          const px=pt.x+Math.cos(angle)*r|0;
          const py=pt.y+Math.sin(angle)*r|0;
          if(px>=0 && py>=0 && px<canvas.width && py<canvas.height){
            ctx.fillRect(px,py,1,1);
            pixelIDs[py][px]=nextID++;
          }
        }
      } else if(tool==="square"){
        ctx.fillRect(pt.x-half,pt.y-half,brushSize,brushSize);
        for(let py2=pt.y-half; py2<pt.y+half; py2++){
          if(py2<0||py2>=canvas.height) continue;
          for(let px2=pt.x-half; px2<pt.x+half; px2++){
            if(px2<0||px2>=canvas.width) continue;
            pixelIDs[py2][px2]=nextID++;
          }
        }
      } else { // round paint/eraser
        ctx.beginPath();
        ctx.arc(pt.x,pt.y,half,0,Math.PI*2);
        ctx.fill();
        for(let py2=pt.y-half; py2<pt.y+half; py2++){
          if(py2<0||py2>=canvas.height) continue;
          for(let px2=pt.x-half; px2<pt.x+half; px2++){
            if(px2<0||px2>=canvas.width) continue;
            pixelIDs[py2][px2]=nextID++;
          }
        }
      }
    }
  } else if(tool==="smudge"){
    const radius=Math.floor(brushSize/2);
    const mask=createBrushMask(radius);
    const points=interpolate(lastX,lastY,x,y,1);

    for(const pt of points){
      const px=Math.floor(pt.x-radius), py=Math.floor(pt.y-radius);
      if(px<0||py<0||px+brushSize>canvas.width||py+brushSize>canvas.height) continue;

      const img=ctx.getImageData(px,py,brushSize,brushSize);
      const data=img.data;
      const buffer=new Uint8ClampedArray(data); 

      const dx=pt.x-lastX, dy=pt.y-lastY;

      for(let j=0;j<brushSize;j++){
        for(let i=0;i<brushSize;i++){
          const idx=(j*brushSize+i)*4;
          const a=mask[j*brushSize+i]*strength;
          if(a<=0) continue;

          let srcX=Math.min(Math.max(i-Math.round(dx),0),brushSize-1);
          let srcY=Math.min(Math.max(j-Math.round(dy),0),brushSize-1);
          const sIdx=(srcY*brushSize+srcX)*4;

          if(isPainted(buffer[sIdx], buffer[sIdx+1], buffer[sIdx+2], buffer[sIdx+3])){
            data[idx]   = Math.min(255, buffer[sIdx]*a + data[idx]*(1-a));
            data[idx+1] = Math.min(255, buffer[sIdx+1]*a + data[idx+1]*(1-a));
            data[idx+2] = Math.min(255, buffer[sIdx+2]*a + data[idx+2]*(1-a));
            data[idx+3] = 255;

            const canvasX = px+i, canvasY = py+j;
            if(canvasX>=0 && canvasX<canvas.width && canvasY>=0 && canvasY<canvas.height){
              pixelIDs[canvasY][canvasX] = nextID++;
            }
          }
        }
      }
      ctx.putImageData(img,px,py);
    }
  }

  lastX=x; lastY=y;
}

// Event listeners
canvas.addEventListener("mousedown",startDraw);
canvas.addEventListener("mousemove",draw);
canvas.addEventListener("mouseup",endDraw);
canvas.addEventListener("mouseout",endDraw);
canvas.addEventListener("touchstart",startDraw);
canvas.addEventListener("touchmove",draw);
canvas.addEventListener("touchend",endDraw);
canvas.addEventListener("touchcancel",endDraw);

// Buttons
clearBtn.addEventListener("click",()=>{
  saveHistory();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  pixelIDs = Array.from({length:canvas.height},()=>Array(canvas.width).fill(0));
});
undoBtn.addEventListener("click",undo);
redoBtn.addEventListener("click",redo);
saveImgBtn.addEventListener("click",downloadCanvas);
saveJSONBtn.addEventListener("click",downloadJSON);
loadJSONInput.addEventListener("change",loadJSON);
</script>
</body>
</html>